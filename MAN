	/****  ****/
	#include <arpa/inet.h> //htons

	uint16_t hostshort;
	htons(hostshort);
	//The htons() function converts the unsigned short integer hostshort from host byte order to network byte order.

	uint32_t hostlong;
	htonl(hostlong);
	//The htonl() function converts the unsigned integer hostlong from host byte order to network byte order.

	uint16_t netshort;
	ntohs(netshort);
    //The ntohs() function converts the unsigned short integer netshort from network byte order to host byte order.

	//On the i386 the host byte order is Least Significant Byte first, whereas the network byte order, as used on the Internet, is Most Significant Byte first.

	/**** select ****/
	#include <sys/select.h>

	select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
	//select()  and pselect() allow a program to monitor multiple file descriptors,
	//waiting until one or more of the file descriptors become "ready" for some class of I/O op‐ eration (e.g., input possible).
	//A file descriptor is considered ready if it is possible to perform a corresponding I/O operation  (e.g.,  read(2),  or  a  sufficiently
	//small write(2)) without blocking.

	/**** poll ****/
	#include <poll.h> //poll
	#include <sys/epoll.h> //wpoll

	poll(struct pollfd *fds, nfds_t nfds, int timeout);
	//poll() performs a similar task to select(2): it waits for one of a set of file descriptors to become ready to perform I/O.

	/***** epoll *****/

	epoll_create(int size);
	//epoll_create() creates a new epoll(7) instance.
	//
	epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
	//This  system call is used to add, modify, or remove entries in the interest list of the epoll(7) instance referred to by the file descriptor epfd.
	//It requests that the operation op be performed for the target file descriptor, fd.

	kqueue();
	kevent();

	/**** socket *****/

	#include <sys/types.h>
	#include <sys/socket.h>
	socket(int domain, int type, int protocol);
	//socket() creates an endpoint for communication and returns a file descriptor that refers to that endpoint.  The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process.

	accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	//The  accept()  system call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file
    //   descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call

	listen(int sockfd, int backlog);
	//listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(2).
	//The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET.
	//The  backlog  argument defines the maximum length to which the queue of pending connections for sockfd may grow.  If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol
	//supports retransmission, the request may be ignored so that a later reattempt at connection succeeds.

	send(int sockfd, const void *buf, size_t len, int flags);
	//The system calls send(), sendto(), and sendmsg() are used to transmit a message to another socket.

	recv(int sockfd, void *buf, size_t len, int flags);
	//The  recv(), recvfrom(), and recvmsg() calls are used to receive messages from a socket.  They may be used to receive data on both connectionless and connection-oriented sockets.  This page first describes common features of all three system calls, and then describes
	//the differences between the calls.

	bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	//When a socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it.  bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd.  addrlen specifies the size, in bytes, of the
	//address structure pointed to by addr.  Traditionally, this operation is called “assigning a name to a socket”.

	connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	//The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr.  The addrlen argument specifies the size of addr.  The format of the address in addr is determined by the address space of the socket sockfd; see
	//socket(2) for further details.

	inet_addr(const char *cp);
	//The  inet_addr()  function converts the Internet host address cp from IPv4 numbers-and-dots notation into binary data in network byte order.  If the input is invalid, INADDR_NONE (usually -1) is returned.  Use of this function is problematic because -1 is a valid ad‐
	//dress (255.255.255.255).  Avoid its use in favor of inet_aton(), inet_pton(3), or getaddrinfo(3), which provide a cleaner way to indicate error return.

	setsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);
	//getsockopt() and setsockopt() manipulate options for the socket referred to by the file descriptor sockfd.  Options may exist at multiple protocol levels; they are always present at the uppermost socket level.

	getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
	//getsockname()  returns  the current address to which the socket sockfd is bound, in the buffer pointed to by addr.  The addrlen argument should be initialized to indicate the amount of space (in bytes) pointed to by addr.  On return it contains the actual size of the
	//socket address.
	//The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was supplied to the call.

	fcntl(int fd, int cmd, ... /* arg */ );
	//fcntl() performs one of the operations described below on the open file descriptor fd.  The operation is determined by cmd.

	return 0;
}
